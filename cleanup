#!/usr/bin/env bash
#
# macOS dev-machine cleanup helper
#
# Usage:
#   cleanup                       # normal cleanup
#   cleanup --dry-run             # show what would be done
#   cleanup --confirm             # ask before executing
#   cleanup --deep                # more aggressive Docker cleanup
#   cleanup --report              # show disk usage report after cleanup
#   cleanup --version             # show version
#   cleanup --self-update         # git-based self update (if script lives in a git repo)
#

set -euo pipefail

VERSION="0.3.0"

# Where this script lives
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# ----- Config defaults (can be overridden in ~/.cleanup.conf) -----
CLEANUP_DEFAULT_CONFIRM=${CLEANUP_DEFAULT_CONFIRM:-0}
CLEANUP_DEFAULT_DEEP=${CLEANUP_DEFAULT_DEEP:-0}
CLEANUP_DEFAULT_REPORT=${CLEANUP_DEFAULT_REPORT:-1}
CLEANUP_LOGGING=${CLEANUP_LOGGING:-1}
CLEANUP_LOG_DIR=${CLEANUP_LOG_DIR:-"$HOME/.cleanup/logs"}
CLEANUP_CONFIG_FILE=${CLEANUP_CONFIG_FILE:-"$HOME/.cleanup.conf"}

# ----- Load optional config file -----
if [ -f "$CLEANUP_CONFIG_FILE" ]; then
  # shellcheck source=/dev/null
  . "$CLEANUP_CONFIG_FILE"
fi

usage() {
  cat <<EOF
cleanup $VERSION

Usage: cleanup [options]
       cleanup version [patch|minor|major]

Options:
  --dry-run       Show what would be cleaned, but don't delete anything
  --confirm       Ask for confirmation before running
  --deep          Run deeper cleanup (e.g. Docker volumes & images)
  --report        Show a disk usage summary after cleanup
  --version       Print the cleanup version and exit
  --self-update   Update this script from its git remote (if in a git repo)
  -h, --help      Show this help

Version Management:
  version patch   Bump patch version (e.g. 0.2.0 -> 0.2.1)
  version minor   Bump minor version (e.g. 0.2.0 -> 0.3.0)
  version major   Bump major version (e.g. 0.2.0 -> 1.0.0)
EOF
}

bump_version() {
  local bump_type="$1"
  local script_file="${BASH_SOURCE[0]}"

  # Parse current version
  IFS='.' read -r major minor patch <<< "$VERSION"

  case "$bump_type" in
    patch)
      patch=$((patch + 1))
      ;;
    minor)
      minor=$((minor + 1))
      patch=0
      ;;
    major)
      major=$((major + 1))
      minor=0
      patch=0
      ;;
    *)
      echo "âŒ Invalid bump type: $bump_type. Use: patch, minor, or major"
      return 1
      ;;
  esac

  local new_version="${major}.${minor}.${patch}"

  echo "ğŸ“¦ Bumping version from $VERSION to $new_version"

  # Update version in script
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' "s/^VERSION=\".*\"/VERSION=\"$new_version\"/" "$script_file"
  else
    sed -i "s/^VERSION=\".*\"/VERSION=\"$new_version\"/" "$script_file"
  fi

  # Check if in git repo
  if command -v git >/dev/null 2>&1 && [ -d "$SCRIPT_DIR/.git" ]; then
    echo "ğŸ“ Creating git commit and tag..."
    git add "$script_file"
    git commit -m "chore: bump version to $new_version"
    git tag -a "v$new_version" -m "Release version $new_version"
    echo "âœ… Version bumped to $new_version"
    echo "ğŸ’¡ Push with: git push && git push --tags"
  else
    echo "âœ… Version bumped to $new_version in script"
    echo "âš ï¸  Not in a git repository - no commit/tag created"
  fi
}

self_update() {
  if command -v git >/dev/null 2>&1 && [ -d "$SCRIPT_DIR/.git" ]; then
    echo "ğŸ”„ Self-updating cleanup from git remote in: $SCRIPT_DIR"
    (cd "$SCRIPT_DIR" && git pull --rebase) || {
      echo "âš ï¸  git pull failed. Check your network/remote."
      return 1
    }
    echo "âœ… Update complete."
  else
    echo "âš ï¸  Self-update requires this script to be in a git clone."
    echo "    Current directory: $SCRIPT_DIR"
    echo "    Hint: git init && git remote add origin <repo> && git pull"
  fi
}

# ----- Runtime flags (CLI overrides config defaults) -----
DRY_RUN=0
CONFIRM=${CLEANUP_DEFAULT_CONFIRM:-0}
DEEP=${CLEANUP_DEFAULT_DEEP:-0}
REPORT=${CLEANUP_DEFAULT_REPORT:-0}
SELF_UPDATE=0

# ----- Parse args -----
# Handle 'cleanup version [patch|minor|major]' subcommand first
if [ "${1:-}" = "version" ]; then
  if [ -z "${2:-}" ]; then
    echo "âŒ Usage: cleanup version [patch|minor|major]"
    exit 1
  fi
  bump_version "$2"
  exit $?
fi

for arg in "$@"; do
  case "$arg" in
    --dry-run) DRY_RUN=1 ;;
    --confirm) CONFIRM=1 ;;
    --deep) DEEP=1 ;;
    --report) REPORT=1 ;;
    --version)
      echo "cleanup $VERSION"
      exit 0
      ;;
    --self-update) SELF_UPDATE=1 ;;
    -h|--help) usage; exit 0 ;;
    *)
      echo "Unknown option: $arg" >&2
      usage
      exit 1
      ;;
  esac
done

# Self-update takes precedence and then exits
if [ "$SELF_UPDATE" -eq 1 ]; then
  self_update
  exit $?
fi

# ----- Optional confirmation -----
if [ "$CONFIRM" -eq 1 ] && [ "$DRY_RUN" -eq 0 ]; then
  echo "About to run cleanup with options:"
  echo "  DRY_RUN = $DRY_RUN"
  echo "  DEEP    = $DEEP"
  echo "  REPORT  = $REPORT"
  read -r -p "Proceed? [y/N] " answer
  case "$answer" in
    [Yy]*) ;;
    *) echo "Aborted."; exit 0 ;;
  esac
fi

# ----- Logging setup -----
TIMESTAMP="$(date +'%Y%m%d-%H%M%S')"
LOG_FILE="$CLEANUP_LOG_DIR/cleanup-$TIMESTAMP.log"

if [ "$DRY_RUN" -eq 0 ] && [ "${CLEANUP_LOGGING:-1}" -eq 1 ]; then
  mkdir -p "$CLEANUP_LOG_DIR"
  # Log everything to file and still display on console
  exec > >(tee -a "$LOG_FILE") 2>&1
  echo "ğŸ“ Logging to: $LOG_FILE"
fi

run_cmd() {
  if [ "$DRY_RUN" -eq 1 ]; then
    echo "DRY RUN: $*"
  else
    "$@"
  fi
}

delete_path() {
  local target="$1"
  if [ ! -e "$target" ]; then
    return 0
  fi

  if [ "$DRY_RUN" -eq 1 ]; then
    echo "DRY RUN: rm -rf \"$target\""
  else
    rm -rf "$target"
  fi
}

echo "ğŸ” Starting system cleanup (dry-run=$DRY_RUN, deep=$DEEP)..."

# --- Homebrew cleanup ---
if command -v brew >/dev/null 2>&1; then
  echo "ğŸ§¹ Cleaning Homebrew..."
  run_cmd brew cleanup -s || true
fi

# --- Node / JS tooling caches ---
echo "ğŸ§¹ Cleaning Node / JS caches..."
if [ -d "$HOME/.npm" ]; then
  run_cmd npm cache clean --force || true
fi
delete_path "$HOME/Library/Caches/pnpm"
delete_path "$HOME/Library/Caches/Yarn"

# --- Python pip cache ---
echo "ğŸ Cleaning Python pip cache..."
delete_path "$HOME/Library/Caches/pip"

# --- RubyGems cache ---
echo "ğŸ’ Cleaning RubyGems cache dirs..."
if [ -d "$HOME/.gem" ]; then
  if [ "$DRY_RUN" -eq 1 ]; then
    echo "DRY RUN: would remove RubyGems cache directories under $HOME/.gem:"
    find "$HOME/.gem" -type d -name cache -print 2>/dev/null || true
  else
    find "$HOME/.gem" -type d -name cache -exec rm -rf {} + 2>/dev/null || true
  fi
fi

# --- VSCode caches ---
echo "ğŸ§  Cleaning VSCode caches..."
VSCODE_BASE="$HOME/Library/Application Support/Code"
delete_path "$VSCODE_BASE/Cache"
delete_path "$VSCODE_BASE/CachedData"
delete_path "$VSCODE_BASE/CachedExtensionVSIXs"

# --- Docker prune (safe) ---
if command -v docker >/dev/null 2>&1; then
  echo "ğŸ³ Cleaning Docker unused resources (safe)..."
  # Check if Docker daemon is responsive (5 second timeout)
  if timeout 5 docker info >/dev/null 2>&1; then
    run_cmd docker system prune -f || true

    if [ "$DEEP" -eq 1 ]; then
      echo "ğŸ³ DEEP: Pruning unused Docker images & volumes..."
      run_cmd docker system prune -af --volumes || true
    fi
  else
    echo "âš ï¸  Docker daemon not responding, skipping Docker cleanup"
  fi
fi

# --- ZSH compdump cleanup ---
echo "ğŸ§¹ Removing old zsh compdump files..."
if [ "$DRY_RUN" -eq 1 ]; then
  echo "DRY RUN: would remove:"
  ls "$HOME"/.zcompdump-* 2>/dev/null || true
else
  rm -f "$HOME"/.zcompdump-* 2>/dev/null || true
fi

# --- JCEF logs (size 0) ---
echo "ğŸ§¹ Removing empty jcef_*.log files in home..."
shopt -s nullglob || true
for f in "$HOME"/jcef_*.log; do
  if [ -e "$f" ] && [ ! -s "$f" ]; then
    if [ "$DRY_RUN" -eq 1 ]; then
      echo "DRY RUN: rm \"$f\""
    else
      rm -f "$f"
    fi
  fi
done
shopt -u nullglob || true

# --- .DS_Store cleanup ---
echo "ğŸ§¹ Removing .DS_Store files..."
if [ "$DRY_RUN" -eq 1 ]; then
  echo "DRY RUN: would remove these .DS_Store files:"
  # Limit to common development directories to avoid scanning entire home
  for dir in "$HOME/Documents" "$HOME/Desktop" "$HOME/Downloads" "$HOME/Projects" "$HOME/src" "$HOME/dev"; do
    [ -d "$dir" ] && find "$dir" -name '.DS_Store' -print 2>/dev/null || true
  done
else
  # Limit to common development directories to avoid scanning entire home
  for dir in "$HOME/Documents" "$HOME/Desktop" "$HOME/Downloads" "$HOME/Projects" "$HOME/src" "$HOME/dev"; do
    [ -d "$dir" ] && find "$dir" -name '.DS_Store' -exec rm -f {} + 2>/dev/null || true
  done
fi

echo "âœ¨ Cleanup steps finished."

# --- Report disk usage ---
if [ "$REPORT" -eq 1 ]; then
  echo
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ“Š Disk Usage Report"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo
  echo "ğŸ“ Top 20 Largest Directories:"
  echo

  # Get and format directory sizes
  du -sh "$HOME"/* 2>/dev/null | sort -h | tail -20 | \
    awk -v home="$HOME" '{
      # Extract just the directory name from the path
      path = $2
      gsub(home"/", "", path)
      printf "  %-45s %10s\n", path, $1
    }' || true

  echo
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
fi

echo "âœ… Done."
